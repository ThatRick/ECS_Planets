import fs from 'node:fs/promises'
import path from 'node:path'

const SOURCE_URL = 'https://planet4589.org/space/con/star/stats.html'
const BASE_URL = 'https://planet4589.org/space/con/star/'
const OUT_FILE = path.join(process.cwd(), 'src', 'data', 'starlinkStatus.ts')

function uniq(arr) {
    return Array.from(new Set(arr))
}

async function fetchText(url) {
    const res = await fetch(url)
    if (!res.ok) throw new Error(`Fetch failed (${res.status}): ${url}`)
    return res.text()
}

function extractUpdatedUtc(html) {
    const m = html.match(/Data last updated:\s*([^<\n]+)/i)
    return m?.[1]?.trim() || 'unknown'
}

function extractMissionIndexLinks(html) {
    const re = /HREF="((?:spl|sg)\d+\/index\.html)"/g
    const links = []
    let m
    while ((m = re.exec(html))) links.push(m[1])
    return uniq(links).sort()
}

function parseStatusRows(html) {
    // Example row:
    // <TR><TD>Starlink 1819</TD><TD>S46670</TD><TD>F</TD>...
    const re = /<TR><TD>[^<]*<\/TD><TD>S(\d+)<\/TD><TD>([A-Za-z])<\/TD>/g
    const rows = []
    let m
    while ((m = re.exec(html))) {
        const noradId = Number.parseInt(m[1], 10)
        const code = m[2]
        if (Number.isFinite(noradId) && noradId > 0 && typeof code === 'string' && code.length === 1) {
            rows.push({ noradId, code })
        }
    }
    return rows
}

async function mapLimit(items, limit, fn) {
    const results = new Array(items.length)
    let nextIndex = 0

    async function worker() {
        while (true) {
            const i = nextIndex++
            if (i >= items.length) return
            results[i] = await fn(items[i], i)
        }
    }

    const workers = []
    for (let i = 0; i < Math.max(1, limit); i++) workers.push(worker())
    await Promise.all(workers)
    return results
}

function encodeBinary(ids, codes) {
    const n = ids.length
    const total = 4 * n + n
    const buf = Buffer.allocUnsafe(total)
    for (let i = 0; i < n; i++) {
        buf.writeUInt32LE(ids[i], i * 4)
    }
    const codesOffset = 4 * n
    for (let i = 0; i < n; i++) {
        buf[codesOffset + i] = codes.charCodeAt(i) & 0xff
    }
    return buf.toString('base64')
}

function formatGeneratedModule({ updatedUtc, count, base64 }) {
    const lines = [
        '// Generated by scripts/update-starlink-status.mjs',
        `// Source: ${SOURCE_URL}`,
        `// Data last updated (UTC): ${updatedUtc}`,
        `// Entries: ${count}`,
        '',
        "export type StarlinkOrbitStatusCode =",
        "    | 'f' // failed to orbit",
        "    | 'F' // screened / early deorbit",
        "    | 'M' // dead / uncontrolled decay",
        "    | 'G' // graveyard",
        "    | 'R' // retiring / disposal underway",
        "    | 'L' // lowered / out of constellation",
        "    | 'U' // anomalous",
        "    | 'T' // reserve / relocating",
        "    | 'S' // special",
        "    | 'D' // drift",
        "    | 'A' // ascent",
        "    | 'O' // operational shell",
        '',
        `export const STARLINK_STATUS_SOURCE_URL = ${JSON.stringify(SOURCE_URL)}`,
        `export const STARLINK_STATUS_UPDATED_UTC = ${JSON.stringify(updatedUtc)}`,
        '',
        `const DATA_BASE64 = ${JSON.stringify(base64)}`,
        '',
        'type Decoded = {',
        '    ids: Uint32Array',
        '    codes: Uint8Array',
        '}',
        '',
        'let decoded: Decoded | null = null',
        '',
        'function decodeBase64(base64: string): Uint8Array {',
        '    const bin = atob(base64)',
        '    const bytes = new Uint8Array(bin.length)',
        '    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i)',
        '    return bytes',
        '}',
        '',
        'function getDecoded(): Decoded {',
        '    if (decoded) return decoded',
        '',
        '    const bytes = decodeBase64(DATA_BASE64)',
        '    const n = bytes.byteLength / 5',
        '    if (!Number.isInteger(n)) {',
        "        throw new Error('Invalid Starlink status blob')",
        '    }',
        '',
        '    // Make a tightly packed ArrayBuffer at offset 0.',
        '    const buf = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength)',
        '    const ids = new Uint32Array(buf, 0, n)',
        '    const codes = new Uint8Array(buf, 4 * n, n)',
        '',
        '    decoded = { ids, codes }',
        '    return decoded',
        '}',
        '',
        'export function getStarlinkOrbitStatusCode(noradId: number): StarlinkOrbitStatusCode | undefined {',
        '    if (!Number.isFinite(noradId) || noradId <= 0) return undefined',
        '',
        '    const { ids, codes } = getDecoded()',
        '',
        '    // Binary search (ids are sorted ascending)',
        '    let lo = 0',
        '    let hi = ids.length - 1',
        '    const target = noradId >>> 0',
        '',
        '    while (lo <= hi) {',
        '        const mid = (lo + hi) >>> 1',
        '        const v = ids[mid]',
        '        if (v === target) {',
        '            return String.fromCharCode(codes[mid]) as StarlinkOrbitStatusCode',
        '        }',
        '        if (v < target) lo = mid + 1',
        '        else hi = mid - 1',
        '    }',
        '',
        '    return undefined',
        '}',
        ''
    ]

    return lines.join('\n')
}

async function main() {
    console.log(`Fetching ${SOURCE_URL}`)
    const statsHtml = await fetchText(SOURCE_URL)
    const updatedUtc = extractUpdatedUtc(statsHtml)
    const links = extractMissionIndexLinks(statsHtml)
    console.log(`Found ${links.length} mission index pages`)

    const statusByNorad = new Map()
    const concurrency = 10

    await mapLimit(links, concurrency, async (rel, i) => {
        const url = BASE_URL + rel
        const html = await fetchText(url)
        const rows = parseStatusRows(html)
        for (const { noradId, code } of rows) {
            statusByNorad.set(noradId, code)
        }
        if ((i + 1) % 25 === 0 || i === links.length - 1) {
            console.log(`  Parsed ${i + 1}/${links.length} pages (entries: ${statusByNorad.size})`)
        }
    })

    const ids = Array.from(statusByNorad.keys()).sort((a, b) => a - b)
    const codes = ids.map((id) => statusByNorad.get(id)).join('')
    const base64 = encodeBinary(ids, codes)

    await fs.mkdir(path.dirname(OUT_FILE), { recursive: true })
    const content = formatGeneratedModule({ updatedUtc, count: ids.length, base64 })
    await fs.writeFile(OUT_FILE, content, 'utf8')
    console.log(`Wrote ${OUT_FILE} (${ids.length} entries)`)
}

await main()
